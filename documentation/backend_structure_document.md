# Backend Structure Document for Flumberico

This document outlines the backend architecture, hosting solutions, and infrastructure components for the Flumberico AI-powered job hunting service. It is written in clear, everyday language so that anyone can understand how the backend is set up and why each choice was made.

## 1. Backend Architecture

Overall, the Flumberico backend is built as a modular, service-oriented system using modern JavaScript technologies. It follows a clear pattern that separates concerns (data access, business logic, and presentation) and groups related features into modules.

Key design choices and patterns:

- Framework: NestJS (a Node.js framework) for its built-in modularity, dependency injection, and structured organization.
- Architecture style: Model-View-Controller (MVC) with a clear distinction between Controllers (API endpoints), Services (business logic), and Repositories (data access).
- Modularity: Separate modules for Authentication, Users, Waitlist, Referrals, Job Preferences, and AI Matching. Each module has its own controllers, services, and data models.
- Scalability: Modules can be split into independent microservices if needed. The service layer is stateless, allowing horizontal scaling by adding more instances behind a load balancer.
- Maintainability: Each feature lives in its own folder, tests are colocated with code, and shared utilities (e.g., error handling, logging) live in a common `core` module.
- Performance: Uses asynchronous I/O (async/await), connection pooling for the database, and Redis caching for frequent reads (e.g., referral lookups).

### Tech Stack (backend)

- Node.js and NestJS (TypeScript)
- TypeORM or Prisma (ORM for database access)
- PostgreSQL (relational database)
- Redis (in-memory cache)
- JWT (JSON Web Tokens) for authentication
- Docker (containerization)
- AWS services: ECS/EKS, RDS, ElastiCache, S3
- CloudFront (CDN) and AWS Application Load Balancer
- GitHub Actions (CI/CD)

## 2. Database Management

Flumberico uses a combination of relational storage and in-memory caching:

- Primary database: PostgreSQL for structured, relational data (users, waitlist entries, referrals, job preferences).
- Caching: Redis to store session data, rate-limiting counters, and frequently accessed lookup tables (e.g., referral codes).
- Data access: A modern ORM (Prisma or TypeORM) handles queries, migrations, and schema synchronization.
- Connection pooling: Ensures the database can handle multiple concurrent requests without exhaustion.
- Backups and recovery: Automated nightly backups of the PostgreSQL database, point-in-time recovery enabled.

## 3. Database Schema

Below is a human-readable description of the main tables, followed by a sample PostgreSQL schema in SQL form.

### Human-Readable Schema

- **users**: Stores registered user accounts (email, password hash, profile details, creation date).
- **waitlist_entries**: Records users or visitors who opt into the waitlist (name, email, signup timestamp).
- **referrals**: Tracks referral codes generated by users and who they invited (referrer_id, invitee_email, code, status).
- **job_preferences**: Captures onboarding form answers (user_id, preferred roles, locations, industries).
- **ai_matches**: Logs AI-generated job recommendations for auditing (user_id, job_id, match_score, timestamp).

### PostgreSQL Schema (SQL)

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  full_name VARCHAR(255),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE waitlist_entries (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255),
  email VARCHAR(255) UNIQUE NOT NULL,
  signed_up_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE referrals (
  id SERIAL PRIMARY KEY,
  referrer_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  invitee_email VARCHAR(255) NOT NULL,
  code VARCHAR(100) UNIQUE NOT NULL,
  status VARCHAR(50) DEFAULT 'pending',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE job_preferences (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  preferred_roles TEXT[],
  preferred_locations TEXT[],
  preferred_industries TEXT[],
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE ai_matches (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  job_id VARCHAR(100) NOT NULL,
  match_score NUMERIC(5,2),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```  

## 4. API Design and Endpoints

The backend exposes a set of RESTful endpoints that the frontend calls to sign users up, manage referrals, and fetch AI job matches.

Key endpoints:

- **Authentication**
  - POST `/api/auth/signup`  → Register a new user
  - POST `/api/auth/login`   → Log in and receive a JWT
  - GET  `/api/auth/profile` → Fetch the current user’s profile (requires JWT)

- **Waitlist**
  - POST `/api/waitlist`     → Add an email/name to the waitlist
  - GET  `/api/waitlist/:email/status` → Check waitlist status

- **Referrals**
  - POST `/api/referrals`    → Generate or send a referral code (requires auth)
  - GET  `/api/referrals/:code` → Validate a referral code
  - GET  `/api/referrals`    → List referrals for the current user (requires auth)

- **Onboarding & AI Matching**
  - POST `/api/preferences`  → Save user’s job preferences (requires auth)
  - GET  `/api/matches`      → Fetch AI-matched jobs based on saved preferences (requires auth)

Each endpoint validates input, handles errors with clear messages, and returns JSON. All protected routes require a valid JWT in the `Authorization` header.

## 5. Hosting Solutions

The backend runs on Amazon Web Services for reliability, scalability, and cost control:

- **Compute**: Docker containers on AWS Fargate (part of ECS) to eliminate server management.
- **Database**: Amazon RDS for PostgreSQL with Multi-AZ deployment for high availability.
- **Cache**: Amazon ElastiCache (Redis) for fast, in-memory data access.
- **Storage**: Amazon S3 for any file assets (e.g., user uploads, logs).

Benefits:

- **Reliability**: Managed services with built-in failover.
- **Scalability**: Automatic scaling of containers and database read replicas.
- **Cost-effectiveness**: Pay-as-you-go, with the ability to right-size services based on demand.

## 6. Infrastructure Components

These components work together to deliver a fast, reliable experience:

- **Load Balancer** (AWS Application Load Balancer): Distributes incoming traffic across multiple container instances.
- **API Gateway** (optional): Provides rate limiting and a unified entry point for all REST endpoints.
- **CDN** (CloudFront): Caches static assets and API responses at edge locations for low-latency access.
- **Redis Cache**: Speeds up frequent data reads (e.g., referral lookups, session checks).
- **Docker & ECS**: Containerization ensures consistency between development, testing, and production.
- **Secrets Management** (AWS Secrets Manager): Securely stores database credentials and API keys.

## 7. Security Measures

Security is woven into every layer of the backend:

- **HTTPS/TLS**: All traffic is encrypted in transit.
- **Authentication**: JWT tokens with expiration and refresh logic.
- **Authorization**: Role-based checks in controllers ensure users only access their own data.
- **Input Validation**: DTOs and validation pipes in NestJS guard against malformed requests.
- **Data Encryption**: Sensitive fields (like passwords) are hashed before storage; RDS encryption at rest is enabled.
- **Rate Limiting**: Protects endpoints from abuse (e.g., too many login attempts).
- **Vulnerability Scanning**: Container images scanned for known CVEs before deployment.

## 8. Monitoring and Maintenance

To keep things running smoothly, we use:

- **Logging**: Centralized logs in AWS CloudWatch, with structured JSON entries for easy searching.
- **Metrics**: CPU, memory, and response time metrics collected by CloudWatch and visualized in Grafana.
- **Alerts**: Automated alerts for high error rates, CPU spikes, or database connection issues.
- **Backups**: Daily snapshots of RDS, with point-in-time restore capabilities.
- **Health Checks**: ECS container health checks restart unhealthy instances automatically.
- **CI/CD**: GitHub Actions pipeline runs tests, linting, and deploys to staging or production upon merge.

## 9. Conclusion and Overall Backend Summary

The Flumberico backend is built to support rapid user growth, handle data securely, and deliver quick responses for the landing page and onboarding flows. By leveraging a modular NestJS architecture, managed AWS services, and best practices in security and monitoring, we ensure:

- **Scalability**: Automatic expansion to meet demand without manual intervention.
- **Reliability**: High availability through managed databases, health checks, and automated failover.
- **Maintainability**: Clear separation of concerns, well-documented modules, and automated testing.
- **Performance**: Fast API responses aided by caching, load balancing, and CDN distribution.

This setup aligns with Flumberico’s goals of providing a seamless user experience, protecting user data, and enabling the team to iterate quickly on new features such as advanced AI matching or referral campaigns.